From 0c60407ccd3aa2778254636349083cf993984178 Mon Sep 17 00:00:00 2001
From: Ban Feng <kcfeng0@nuvoton.com>
Date: Thu, 26 Sep 2024 13:32:18 +0800
Subject: [PATCH] driver: soc: nuvoton: add espi slave driver

Signed-off-by: Ban Feng <kcfeng0@nuvoton.com>
Signed-off-by: Joseph Liu <kwliu@nuvoton.com>
---
 .../dts/nuvoton/nuvoton-common-npcm8xx.dtsi   |   5 +
 .../boot/dts/nuvoton/nuvoton-npcm845-evb.dts  |   4 +
 drivers/soc/nuvoton/Kconfig                   |   7 +
 drivers/soc/nuvoton/Makefile                  |   1 +
 drivers/soc/nuvoton/npcm-espi-slave.c         | 300 ++++++++++++++++++
 5 files changed, 317 insertions(+)
 create mode 100644 drivers/soc/nuvoton/npcm-espi-slave.c

diff --git a/arch/arm64/boot/dts/nuvoton/nuvoton-common-npcm8xx.dtsi b/arch/arm64/boot/dts/nuvoton/nuvoton-common-npcm8xx.dtsi
index 4a49ed86937c..232bc6bf9fcd 100644
--- a/arch/arm64/boot/dts/nuvoton/nuvoton-common-npcm8xx.dtsi
+++ b/arch/arm64/boot/dts/nuvoton/nuvoton-common-npcm8xx.dtsi
@@ -355,6 +355,11 @@ vw_gpio: vw_gpio {
 					#gpio-cells = <2>;
 					status = "disabled";
 				};
+				espi_slave: espi_slave {
+					compatible = "nuvoton,npcm845-espi-slave";
+					interrupts = <GIC_SPI 18 IRQ_TYPE_LEVEL_HIGH>;
+					status = "disabled";
+				};
 			};
 
 			peci0: peci-controller@100000 {
diff --git a/arch/arm64/boot/dts/nuvoton/nuvoton-npcm845-evb.dts b/arch/arm64/boot/dts/nuvoton/nuvoton-npcm845-evb.dts
index bcb5657aa5b9..946c67d596c1 100644
--- a/arch/arm64/boot/dts/nuvoton/nuvoton-npcm845-evb.dts
+++ b/arch/arm64/boot/dts/nuvoton/nuvoton-npcm845-evb.dts
@@ -747,3 +747,7 @@ &ece {
 &tip_mbox {
 	status = "okay";
 };
+
+&espi_slave {
+	status = "okay";
+};
diff --git a/drivers/soc/nuvoton/Kconfig b/drivers/soc/nuvoton/Kconfig
index e20b7c2350ae..d4a77cbbc6ea 100644
--- a/drivers/soc/nuvoton/Kconfig
+++ b/drivers/soc/nuvoton/Kconfig
@@ -56,4 +56,11 @@ config MTD_NPCM_TIP_FIU
 	help
 	  This enables access to NOR device thourgh TIP in NPCM BMC's.
 
+config NPCM_ESPI_SLAVE
+	tristate "NPCM SLAVE Driver"
+	depends on ARCH_NPCM || COMPILE_TEST
+	help
+	  Provides a driver to implement the espi slave driver that
+	  handle the espi events.
+
 endmenu
diff --git a/drivers/soc/nuvoton/Makefile b/drivers/soc/nuvoton/Makefile
index 38753becb592..7597edc7bb52 100644
--- a/drivers/soc/nuvoton/Makefile
+++ b/drivers/soc/nuvoton/Makefile
@@ -5,3 +5,4 @@ obj-$(CONFIG_WPCM450_SOC)	+= wpcm450-soc.o
 obj-$(CONFIG_NPCM_SERIAL_PORT_CONTROL) += npcm-sp-ctrl.o
 obj-$(CONFIG_NPCM_ESPI_MMBI) += npcm-espi-mmbi.o
 obj-$(CONFIG_MTD_NPCM_TIP_FIU)	+= npcm_fiu_tip.o
+obj-$(CONFIG_NPCM_ESPI_SLAVE) += npcm-espi-slave.o
\ No newline at end of file
diff --git a/drivers/soc/nuvoton/npcm-espi-slave.c b/drivers/soc/nuvoton/npcm-espi-slave.c
new file mode 100644
index 000000000000..20090b21fc0b
--- /dev/null
+++ b/drivers/soc/nuvoton/npcm-espi-slave.c
@@ -0,0 +1,300 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2021 Intel Corporation.
+ * Copyright (c) 2024 Nuvoton Technology corporation.
+ */
+
+#include <linux/fs.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/mfd/syscon.h>
+#include <linux/miscdevice.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/poll.h>
+#include <linux/regmap.h>
+#include <linux/sched/signal.h>
+#include <linux/spinlock.h>
+#include <linux/uaccess.h>
+
+#define DEVICE_NAME "espi-pltrstn"
+
+#define ESPISTS			0x008
+#define  ESPISTS_PLTRST		BIT(10)
+#define  ESPISTS_ESPIRST	BIT(9)
+#define  ESPISTS_CFGUPD		BIT(1)
+
+#define ESPIIE			0x00C
+#define  ESPIIE_PLTRSTIE	BIT(10)
+#define  ESPIIE_ESPIRSTIE	BIT(9)
+#define  ESPIIE_CFGUPDIE	BIT(1)
+
+#define VWEVMS1			0x144
+#define  VWEVMS1_PLTRST		BIT(1)
+
+struct npcm_espi_slave {
+	struct regmap		*espi_regmap;
+	struct device		*dev;
+	int			irq;
+
+	/* for PLTRST_N signal monitoring interface */
+	struct miscdevice	miscdev;
+	/* for SMI Interrupt monitoring interface */
+	spinlock_t		pltrstn_lock; /* for PLTRST_N signal sampling */
+	wait_queue_head_t	pltrstn_waitq;
+	char			pltrstn;
+	bool			pltrstn_in_avail;
+};
+
+
+static void npcm_espi_slave_config_irq(struct npcm_espi_slave *priv)
+{
+	regmap_update_bits(priv->espi_regmap, ESPIIE, ESPIIE_PLTRSTIE,
+			ESPIIE_PLTRSTIE);
+	regmap_update_bits(priv->espi_regmap, ESPIIE, ESPIIE_ESPIRSTIE,
+			ESPIIE_ESPIRSTIE);
+	regmap_update_bits(priv->espi_regmap, ESPIIE, ESPIIE_CFGUPDIE,
+			ESPIIE_CFGUPDIE);
+}
+
+static irqreturn_t npcm_espi_slave_irq_handler(int irq, void *arg)
+{
+	struct npcm_espi_slave *priv = arg;
+	uint32_t sts, evms1;
+
+	regmap_read(priv->espi_regmap, ESPISTS, &sts);
+	regmap_read(priv->espi_regmap, VWEVMS1, &evms1);
+
+	dev_info(priv->dev, "+ INT_STS: 0x%08x, pltrstn: %c, vwevms1: 0x%08x\n", sts, priv->pltrstn, evms1);
+
+	if (sts & ESPISTS_CFGUPD) {
+		spin_lock(&priv->pltrstn_lock);
+		priv->pltrstn = (evms1 & VWEVMS1_PLTRST) ? '1' : '0';
+		priv->pltrstn_in_avail = true;
+		spin_unlock(&priv->pltrstn_lock);
+		wake_up_interruptible(&priv->pltrstn_waitq);
+		dev_info(priv->dev, "CFGUPD SYSEVT_PLTRSTN: %c\n", priv->pltrstn);
+
+		regmap_write_bits(priv->espi_regmap, ESPISTS,
+					ESPISTS_CFGUPD, ESPISTS_CFGUPD);
+	}
+
+	if (sts & ESPISTS_PLTRST) {
+		spin_lock(&priv->pltrstn_lock);
+		priv->pltrstn = '0';
+		priv->pltrstn_in_avail = true;
+		spin_unlock(&priv->pltrstn_lock);
+		wake_up_interruptible(&priv->pltrstn_waitq);
+		dev_info(priv->dev, "PLTRST SYSEVT_PLTRSTN: %c\n", priv->pltrstn);
+
+		regmap_write_bits(priv->espi_regmap, ESPISTS,
+					ESPISTS_PLTRST, ESPISTS_PLTRST);
+	}
+
+	if (sts & ESPISTS_ESPIRST) {
+		spin_lock(&priv->pltrstn_lock);
+		priv->pltrstn = 'U';
+		priv->pltrstn_in_avail = true;
+		spin_unlock(&priv->pltrstn_lock);
+		wake_up_interruptible(&priv->pltrstn_waitq);
+		dev_info(priv->dev, "ESPIRST SYSEVT_PLTRSTN: %c\n", priv->pltrstn);
+
+		regmap_write_bits(priv->espi_regmap, ESPISTS,
+					ESPISTS_ESPIRST, ESPISTS_ESPIRST);
+
+		npcm_espi_slave_config_irq(priv);
+	}
+
+	regmap_read(priv->espi_regmap, ESPISTS, &sts);
+	dev_info(priv->dev, "- INT_STS: 0x%08x\n", sts);
+
+	return IRQ_HANDLED;
+}
+
+static inline struct npcm_espi_slave *to_npcm_espi_slave(struct file *filp)
+{
+	return container_of(filp->private_data, struct npcm_espi_slave,
+			    miscdev);
+}
+
+
+static int npcm_espi_slave_pltrstn_open(struct inode *inode, struct file *filp)
+{
+	struct npcm_espi_slave *priv = to_npcm_espi_slave(filp);
+
+	if ((filp->f_flags & O_ACCMODE) != O_RDONLY)
+		return -EACCES;
+	priv->pltrstn_in_avail = true ; /*Setting true returns first data after file open*/
+
+	return 0;
+}
+
+
+static ssize_t npcm_espi_slave_pltrstn_read(struct file *filp, char __user *buf,
+					size_t count, loff_t *offset)
+{
+	struct npcm_espi_slave *priv = to_npcm_espi_slave(filp);
+	DECLARE_WAITQUEUE(wait, current);
+	char data, old_sample;
+	int ret = 0;
+
+	spin_lock_irq(&priv->pltrstn_lock);
+
+	if (filp->f_flags & O_NONBLOCK) {
+		if (!priv->pltrstn_in_avail) {
+			ret = -EAGAIN;
+			goto out_unlock;
+		}
+		data = priv->pltrstn;
+		priv->pltrstn_in_avail = false;
+	} else {
+		add_wait_queue(&priv->pltrstn_waitq, &wait);
+		set_current_state(TASK_INTERRUPTIBLE);
+
+		old_sample = priv->pltrstn;
+
+		do {
+			if (old_sample != priv->pltrstn) {
+				data = priv->pltrstn;
+				priv->pltrstn_in_avail = false;
+				break;
+			}
+
+			if (signal_pending(current)) {
+				ret = -ERESTARTSYS;
+			} else {
+				spin_unlock_irq(&priv->pltrstn_lock);
+				schedule();
+				spin_lock_irq(&priv->pltrstn_lock);
+			}
+		} while (!ret);
+
+		remove_wait_queue(&priv->pltrstn_waitq, &wait);
+		set_current_state(TASK_RUNNING);
+	}
+out_unlock:
+	spin_unlock_irq(&priv->pltrstn_lock);
+
+	if (ret)
+		return ret;
+
+	ret = put_user(data, buf);
+	if (!ret)
+		ret = sizeof(data);
+
+	return ret;
+}
+
+
+static unsigned int npcm_espi_slave_pltrstn_poll(struct file *file,
+						 poll_table *wait)
+{
+	struct npcm_espi_slave *priv = to_npcm_espi_slave(file);
+	unsigned int mask = 0;
+
+	poll_wait(file, &priv->pltrstn_waitq, wait);
+	if (priv->pltrstn_in_avail)
+		mask |= POLLIN;
+	return mask;
+}
+
+
+static const struct file_operations npcm_espi_slave_pltrstn_fops = {
+	.owner	= THIS_MODULE,
+	.open	= npcm_espi_slave_pltrstn_open,
+	.read	= npcm_espi_slave_pltrstn_read,
+	.poll	= npcm_espi_slave_pltrstn_poll,
+};
+
+static int npcm_espi_slave_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct npcm_espi_slave *priv;
+	int ret;
+
+	priv = devm_kzalloc(dev, sizeof(struct npcm_espi_slave), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->espi_regmap = syscon_node_to_regmap(dev->parent->of_node);
+	if (IS_ERR(priv->espi_regmap)) {
+		dev_err(dev, "Couldn't get espiregmap\n");
+		return -ENODEV;
+	}
+
+	priv->miscdev.fops = &npcm_espi_slave_pltrstn_fops;
+	priv->miscdev.parent = &pdev->dev;
+	priv->miscdev.minor = MISC_DYNAMIC_MINOR;
+	priv->miscdev.name = devm_kasprintf(dev, GFP_KERNEL, "%s", DEVICE_NAME);
+	if (!priv->miscdev.name) {
+		ret = -ENOMEM;
+		return ret;
+	}
+
+	ret = misc_register(&priv->miscdev);
+	if (ret) {
+		dev_err(dev, "Unable to register device\n");
+		kfree(priv->miscdev.name);
+		return ret;
+	}
+
+	priv->irq = platform_get_irq(pdev, 0);
+	if (priv->irq < 0)
+		return priv->irq;
+
+	ret = devm_request_irq(dev, priv->irq, npcm_espi_slave_irq_handler,
+			       IRQF_SHARED, "espi-slave", priv);
+	if (ret) {
+		dev_err(dev, "failed to request IRQ\n");
+		return ret;
+	}
+
+	//npcm_espi_slave_config_irq(priv);
+
+	spin_lock_init(&priv->pltrstn_lock);
+	
+	init_waitqueue_head(&priv->pltrstn_waitq);
+
+	priv->pltrstn = 'U'; /* means it's not reported yet from master */
+
+	priv->dev =  &pdev->dev;
+
+	dev_set_drvdata(dev, priv);
+
+	npcm_espi_slave_config_irq(priv);
+
+	dev_info(dev, "eSPI registered, irq %d\n", priv->irq);
+	return 0;
+
+}
+
+static int npcm_espi_slave_remove(struct platform_device *pdev)
+{
+	struct npcm_espi_slave *priv = dev_get_drvdata(&pdev->dev);
+	misc_deregister(&priv->miscdev);
+	kfree(priv->miscdev.name);
+	kfree(priv);
+	return 0;
+}
+
+static const struct of_device_id npcm_espi_slave_match[] = {
+	{ .compatible = "nuvoton,npcm845-espi-slave" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, npcm_espi_slave_match);
+
+static struct platform_driver npcm_espi_slave_driver = {
+	.driver	= {
+		.name           = DEVICE_NAME,
+		.owner		= THIS_MODULE,
+		.of_match_table	= of_match_ptr(npcm_espi_slave_match),
+	},
+	.probe	= npcm_espi_slave_probe,
+	.remove	= npcm_espi_slave_remove,
+};
+module_platform_driver(npcm_espi_slave_driver);
+
+MODULE_DESCRIPTION("NPCM eSPI Slave driver");
+MODULE_LICENSE("GPL v2");
-- 
2.34.1

