From 313a43249302e0312cb1b199548f63a2081c68a6 Mon Sep 17 00:00:00 2001
From: Stanley Chu <yschu@nuvoton.com>
Date: Wed, 30 Oct 2024 13:23:19 +0800
Subject: [PATCH] mctpd: discover remote eid

set fixed local eid for all mctpusb interface.
discover remote eid by get_endpoint_id command.
add route/neigh for remote eid.

Signed-off-by: Stanley Chu <yschu@nuvoton.com>
---
 src/mctpd.c | 142 ++++++++++++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 137 insertions(+), 5 deletions(-)

diff --git a/src/mctpd.c b/src/mctpd.c
index 935881a..6702e5c 100644
--- a/src/mctpd.c
+++ b/src/mctpd.c
@@ -45,6 +45,8 @@
 #define OPENBMC_OBJECT_MAPPER_OBJECT_PATH "/xyz/openbmc_project/object_mapper"
 #define OPENBMC_OBJECT_MAPPER_IFACE "xyz.openbmc_project.ObjectMapper"
 
+#define LOCAL_EID	160
+
 // an arbitrary constant for use with sd_id128_get_machine_app_specific()
 static const char* mctpd_appid = "67369c05-4b97-4b7e-be72-65cfd8639f10";
 
@@ -180,6 +182,7 @@ static int change_net_interface(ctx *ctx, int ifindex, int old_net);
 static int add_local_eid(ctx *ctx, int net, int eid);
 static int del_local_eid(ctx *ctx, int net, int eid);
 static int add_net(ctx *ctx, int net);
+static int discover_remote_endpoint(ctx *ctx, int ifindex);
 
 mctp_eid_t local_addr(const ctx *ctx, int ifindex) {
 	mctp_eid_t *eids, ret = 0;
@@ -887,6 +890,8 @@ static int cb_listen_monitor(sd_event_source *s, int sd, uint32_t revents,
 		{
 			int net = mctp_nl_net_byindex(ctx->nl, c->ifindex);
 			rc = add_local_eid(ctx, net, c->eid);
+			if (rc == 0)
+				rc = discover_remote_endpoint(ctx, c->ifindex);
 			any_error |= (rc < 0);
 		}
 		break;
@@ -1717,6 +1722,121 @@ static int message_read_hwaddr(sd_bus_message *call, dest_phys* dest)
 	return 0;
 }
 
+static int set_link_up(struct ctx *ctx, int ifindex)
+{
+	struct {
+		struct nlmsghdr		nh;
+		struct ifinfomsg	ifmsg;
+		/* Space for all attributes */
+		uint8_t			rta_buff[200];
+	} msg = {0};
+	struct rtattr *rta;
+	size_t rta_len;
+
+	msg.nh.nlmsg_type = RTM_NEWLINK;
+	msg.nh.nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;
+	msg.ifmsg.ifi_index = ifindex;
+
+	msg.nh.nlmsg_len = NLMSG_LENGTH(sizeof(msg.ifmsg));
+	rta_len = sizeof(msg.rta_buff);
+	rta = (void*)msg.rta_buff;
+
+	msg.ifmsg.ifi_change |= IFF_UP;
+	msg.ifmsg.ifi_flags |= IFF_UP;
+
+	return mctp_nl_send(ctx->nl, &msg.nh);
+}
+
+static int set_local_eid(ctx *ctx, int ifindex, uint8_t eid)
+{
+	struct {
+		struct nlmsghdr		nh;
+		struct ifaddrmsg	ifmsg;
+		struct rtattr		rta;
+		uint8_t			data[4];
+	} msg = {0};
+	int rc;
+
+	msg.nh.nlmsg_type = RTM_NEWADDR;
+	// request an error status since there's no other reply
+	msg.nh.nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;
+
+	msg.ifmsg.ifa_index = ifindex;
+	msg.ifmsg.ifa_family = AF_MCTP;
+
+	msg.rta.rta_type = IFA_LOCAL;
+	msg.rta.rta_len = RTA_LENGTH(sizeof(eid));
+	memcpy(RTA_DATA(&msg.rta), &eid, sizeof(eid));
+
+	msg.nh.nlmsg_len = NLMSG_LENGTH(sizeof(msg.ifmsg)) +
+			RTA_SPACE(sizeof(eid));
+
+	return mctp_nl_send(ctx->nl, &msg.nh);
+}
+
+static int discover_remote_endpoint(ctx *ctx, int ifindex)
+{
+	dest_phys dest = {0};
+	mctp_eid_t eid;
+	struct mctp_ctrl_cmd_get_eid req = {0};
+	struct sockaddr_mctp_ext addr;
+	uint8_t ep_type, medium_spec;
+	peer *peer = NULL;
+	int net, rc;
+
+	req.ctrl_hdr.rq_dgram_inst = RQDI_REQ;
+	req.ctrl_hdr.command_code = MCTP_CTRL_CMD_GET_ENDPOINT_ID;
+
+	dest.ifindex = ifindex;
+	dest.hwaddr_len = 0;
+
+	net = mctp_nl_net_byindex(ctx->nl, ifindex);
+	if (net < 1) {
+		warnx("No net for ifindex %d", ifindex);
+		return -EINVAL;
+	}
+
+	rc = query_get_endpoint_id(ctx, &dest, &eid, &ep_type, &medium_spec);
+	if (rc < 0)
+		return rc;
+	fprintf(stderr, "ifindex %d remote eid=%d\n", ifindex, eid);
+
+	peer = find_peer_by_addr(ctx, eid, net);
+	if (peer) {
+		// Endpoint already added
+		return -EEXIST;
+	}
+	rc = add_peer(ctx, &dest, eid, net, NULL, &peer);
+	if (rc < 0) {
+		warnx("Failed to add peer for EID %d", eid);
+		return -EINVAL;
+	}
+
+	add_peer_route(peer);
+
+	uint8_t* buf = NULL;
+	size_t buf_size = 0;
+	rc = endpoint_query_peer(peer, MCTP_CTRL_HDR_MSG_TYPE,
+		&req, sizeof(req), &buf, &buf_size, &addr);
+	if (rc < 0) {
+		warnx("Response timeout for EID %d.", eid);
+		remove_peer(peer);
+		free(buf);
+		return rc;
+	}
+	free(buf);
+
+	rc = query_peer_properties(peer);
+
+	rc = publish_peer(peer, false);
+	if (rc < 0) {
+		warnx("Error publishing remote eid %d net %d", eid, net);
+		return rc;
+	}
+
+	return 0;
+}
+
 static int setup_static_eid(ctx *ctx)
 {
 	char **object_paths;
@@ -2404,17 +2524,17 @@ static int peer_route_update(peer *peer, uint16_t type)
 {
 	const char * link;
 
-	link = mctp_nl_if_byindex(peer->ctx->nl_query, peer->phys.ifindex);
+	link = mctp_nl_if_byindex(peer->ctx->nl, peer->phys.ifindex);
 	if (!link) {
 		warnx("BUG %s: Unknown ifindex %d", __func__, peer->phys.ifindex);
 		return -ENODEV;
 	}
 
 	if (type == RTM_NEWROUTE) {
-		return mctp_nl_route_add(peer->ctx->nl_query,
+		return mctp_nl_route_add(peer->ctx->nl,
 			peer->eid, link, peer->mtu);
 	} else if (type == RTM_DELROUTE) {
-		return mctp_nl_route_del(peer->ctx->nl_query, peer->eid, link);
+		return mctp_nl_route_del(peer->ctx->nl, peer->eid, link);
 	}
 
 	warnx("BUG %s: bad type %d", __func__, type);
@@ -3780,16 +3900,23 @@ static int add_local_eid(ctx *ctx, int net, int eid)
 // Adds peers for local EIDs on an interface
 static int add_interface_local(ctx *ctx, int ifindex)
 {
-	mctp_eid_t *eids = NULL;
+	//mctp_eid_t *eids = NULL;
+	char *ifname = mctp_nl_if_byindex(ctx->nl, ifindex);
 	size_t num;
 	int net;
 	int rc;
 
+	if (strncmp(ifname, "mctpusb", 7))
+		return 0;
+
 	if (ctx->verbose) {
 		fprintf(stderr, "Adding interface #%d %s\n",
 			ifindex, mctp_nl_if_byindex(ctx->nl, ifindex));
 	}
 
+	if (set_link_up(ctx, ifindex) < 0)
+		warnx("fail to set %s link up\n", ifname);
+
 	if (!mctp_nl_up_byindex(ctx->nl, ifindex))
 		warnx("Warning, interface %s is down",
 			mctp_nl_if_byindex(ctx->nl, ifindex));
@@ -3807,11 +3934,16 @@ static int add_interface_local(ctx *ctx, int ifindex)
 			return rc;
 	}
 
+	if (set_local_eid(ctx, ifindex, LOCAL_EID) < 0)
+		warnx("fail to set local eid for %s\n", ifname);
+
+#if 0
 	eids = mctp_nl_addrs_byindex(ctx->nl, ifindex, &num);
 	for (size_t j = 0; j < num; j++) {
 		add_local_eid(ctx, net, eids[j]);
 	}
 	free(eids);
+#endif
 	return 0;
 }
 
@@ -4069,7 +4201,7 @@ int main(int argc, char **argv)
 	if (rc < 0 && !ctx->testing)
 		return 1;
 
-	setup_static_eid(ctx);
+	//setup_static_eid(ctx);
 
 	// TODO add net argument?
 	rc = listen_control_msg(ctx, MCTP_NET_ANY);
-- 
2.34.1

