From 1ea1bcc3c7e0114be0b4ebc057be79052adde4bc Mon Sep 17 00:00:00 2001
From: Brian Ma <chma0@nuvoton.com>
Date: Wed, 1 Dec 2021 17:05:54 +0800
Subject: [PATCH] update_service: fix fwUpdateErrorMatcher cannot working

Because the phosphor logging commit ef952af2 stop emitting the
propChanged signal before ifacesAdded signal raising, the
fwUpdateErrorMatcher cannot get any software error after image update.
Update fwUpdateErrorMatcher to get ifacesAdded dbus signal to handle
software error.

Tested:
  Post bad manifest image and get "Invalid manifest" error response

Signed-off-by: Brian Ma <chma0@nuvoton.com>
Change-Id: I066e0cec0ddf7569dd73b2601f838c697bac24da
---
 redfish-core/lib/update_service.hpp | 141 ++++++++++++++++------------
 1 file changed, 82 insertions(+), 59 deletions(-)

diff --git a/redfish-core/lib/update_service.hpp b/redfish-core/lib/update_service.hpp
index f3987d4c7..569ebda14 100644
--- a/redfish-core/lib/update_service.hpp
+++ b/redfish-core/lib/update_service.hpp
@@ -316,69 +316,92 @@ static void monitorForSoftwareAvailable(
 
     fwUpdateErrorMatcher = std::make_unique<sdbusplus::bus::match::match>(
         *crow::connections::systemBus,
-        "type='signal',member='PropertiesChanged',path_namespace='/xyz/"
-        "openbmc_project/logging/entry',"
-        "arg0='xyz.openbmc_project.Logging.Entry'",
+        "interface='org.freedesktop.DBus.ObjectManager',type='signal',"
+        "member='InterfacesAdded',"
+        "path='/xyz/openbmc_project/logging'",
         [asyncResp, url](sdbusplus::message::message& m) {
-            BMCWEB_LOG_DEBUG << "Error Match fired";
-            boost::container::flat_map<std::string, std::variant<std::string>>
-                values;
-            std::string objName;
-            m.read(objName, values);
-            auto find = values.find("Message");
-            if (find == values.end())
-            {
-                return;
-            }
-            std::string* type = std::get_if<std::string>(&(find->second));
-            if (type == nullptr)
-            {
-                return; // if this was our message, timeout will cover it
-            }
-            if (!boost::starts_with(*type, "xyz.openbmc_project.Software"))
-            {
-                return;
-            }
-            if (*type ==
-                "xyz.openbmc_project.Software.Image.Error.UnTarFailure")
-            {
-                redfish::messages::invalidUpload(asyncResp->res, url,
-                                                 "Invalid archive");
-            }
-            else if (
-                *type ==
-                "xyz.openbmc_project.Software.Image.Error.ManifestFileFailure")
-            {
-                redfish::messages::invalidUpload(asyncResp->res, url,
-                                                 "Invalid manifest");
-            }
-            else if (*type ==
-                     "xyz.openbmc_project.Software.Image.Error.ImageFailure")
+            std::vector<std::pair<
+                std::string,
+                std::vector<std::pair<std::string, std::variant<std::string>>>>>
+                interfacesProperties;
+            sdbusplus::message::object_path objPath;
+            m.read(objPath, interfacesProperties);
+            BMCWEB_LOG_DEBUG << "obj path = " << objPath.str;
+            for (auto& interface : interfacesProperties)
             {
-                redfish::messages::invalidUpload(asyncResp->res, url,
-                                                 "Invalid image format");
-            }
-            else if (*type ==
-                     "xyz.openbmc_project.Software.Version.Error.AlreadyExists")
-            {
-
-                redfish::messages::invalidUpload(
-                    asyncResp->res, url, "Image version already exists");
+                if (interface.first == "xyz.openbmc_project.Logging.Entry")
+                {
+                    BMCWEB_LOG_DEBUG << "Error Match fired";
+                    auto& values = interface.second; // vector<std::pair>
+                    auto find = std::find_if(
+                        values.begin(), values.end(),
+                        [](const std::pair<
+                            std::string, std::variant<std::string>>& valPair) {
+                            return valPair.first == "Message";
+                        });
+                    if (find == values.end())
+                    {
+                        return;
+                    }
+                    std::string* type =
+                        std::get_if<std::string>(&(find->second));
+                    if (type == nullptr)
+                    {
+                        // if this was our message, timeout will cover it
+                        return;
+                    }
+                    if (!boost::starts_with(*type,
+                                            "xyz.openbmc_project.Software"))
+                    {
+                        return;
+                    }
+                    if (*type ==
+                        "xyz.openbmc_project.Software.Image.Error.UnTarFailure")
+                    {
+                        redfish::messages::invalidUpload(asyncResp->res, url,
+                                                         "Invalid archive");
+                    }
+                    else if (*type ==
+                             "xyz.openbmc_project.Software.Image.Error."
+                             "ManifestFileFailure")
+                    {
+                        redfish::messages::invalidUpload(asyncResp->res, url,
+                                                         "Invalid manifest");
+                    }
+                    else if (
+                        *type ==
+                        "xyz.openbmc_project.Software.Image.Error.ImageFailure")
+                    {
+                        redfish::messages::invalidUpload(
+                            asyncResp->res, url, "Invalid image format");
+                    }
+                    else if (
+                        *type ==
+                        "xyz.openbmc_project.Software.Version.Error.AlreadyExists")
+                    {
+                        redfish::messages::invalidUpload(
+                            asyncResp->res, url,
+                            "Image version already exists");
 
-                redfish::messages::resourceAlreadyExists(
-                    asyncResp->res, "UpdateService.v1_5_0.UpdateService",
-                    "Version", "uploaded version");
-            }
-            else if (*type ==
-                     "xyz.openbmc_project.Software.Image.Error.BusyFailure")
-            {
-                redfish::messages::resourceExhaustion(asyncResp->res, url);
-            }
-            else
-            {
-                redfish::messages::internalError(asyncResp->res);
+                        redfish::messages::resourceAlreadyExists(
+                            asyncResp->res,
+                            "UpdateService.v1_5_0.UpdateService", "Version",
+                            "uploaded version");
+                    }
+                    else if (
+                        *type ==
+                        "xyz.openbmc_project.Software.Image.Error.BusyFailure")
+                    {
+                        redfish::messages::resourceExhaustion(asyncResp->res,
+                                                              url);
+                    }
+                    else
+                    {
+                        redfish::messages::internalError(asyncResp->res);
+                    }
+                    fwAvailableTimer = nullptr;
+                }
             }
-            fwAvailableTimer = nullptr;
         });
 }
 
-- 
2.17.1

